#!/bin/bash

checkIfRoot() {
    if ! [ $(id -u) = 0 ]; then
        echo "You must be running this script as root"
        echo "Exiting..."
        exit 126;
    fi
}

detectOS(){
    case $(echo $(uname -s) | tr '[:upper:]' '[:lower:]') in
        darwin*)  os="mac";;
        linux*)   os="linux" ;;
        bsd*)     os="bsd" ;;
        *)        os="unknown" ;;
    esac
}

setResultOutputDir() {
    resultOutputDir="/opt/sentinelone/rso/"  # Default output directory for Linux
    if [ ! -z "$S1_OUTPUT_DIR_PATH" ]; then
        resultOutputDir="$S1_OUTPUT_DIR_PATH"  # Agent supplied the output directory using an environment variable
        if [ ! "$resultOutputDir" = "*/" ]; then
            resultOutputDir="${resultOutputDir}/"  # Append slash at the end
        fi
    fi

    # Create output dir if not exists
    mkdir -p "${resultOutputDir}"
    echo "Script output directory is: $resultOutputDir"
}

echoerr() {
    printf "%s\n" "$*" >&2;
}

checkIfRoot
detectOS
echo "os=$os"
setResultOutputDir


# Create temporary directory for temporary files generated by the script
tempDir="${resultOutputDir}/script_tmp_dir"
mkdir -p "${tempDir}"

setDataSetFilePath() {
    if [ "$os" = "mac" ]; then
        datasetFilePath="/var/sentinelone/rso/dataset.json"
    else
        datasetFilePath="/opt/sentinelone/rso/dataset.json"
    fi

    if [ ! -z "$S1_XDR_OUTPUT_FILE_PATH" ]; then
        datasetFilePath="$S1_XDR_OUTPUT_FILE_PATH"
    fi

    echo "XDR json output file path: $datasetFilePath"
    # Create dataset.json output dir if not exist
    mkdir -p "$(dirname "$datasetFilePath")"
}

# If S1_OUTPUT_DESTINATION variable contains the output destination, create only the file related to destination.
setAddonParserVariables() {
    destinationCloud=true
    destinationDataset=true
    if [ ! -z "$S1_OUTPUT_DESTINATION" ]; then
        if [ "$S1_OUTPUT_DESTINATION" = "Cloud" ]; then
            destinationDataset=false
        elif [ "$S1_OUTPUT_DESTINATION" = "DataSet" ]; then
            destinationCloud=false
        fi
    fi
}

setDataSetFilePath
setAddonParserVariables
scriptFileName=$(basename "$0")
resultFileName="$scriptFileName-results.csv"
shopt -s extglob

# Gets variables by name and creates a json
# where the variable name is the key and its value is the correspondent value
# Example: create_json_from_args "pid" "user"
# Result: {'pid': '{pid variable value}', 'user': '{user variable value}' }
create_json_from_args() {
    str="{"
    arg_index=0
    for key in "$@"; do
        if [ $arg_index -ne 0 ]
        then
            str+=", "
        fi
        value=$(eval "echo \$$key")
        case value in
                ?(+|-)+([0-9])?(\.+([0-9])))  str+="\"$key\":$value"      ;;
            *)                                escapedValue="${value//\\/#}"
                                              escapedValue="${escapedValue//\"/ \\\"}"
                                              str+="\"$key\":\"$escapedValue\"";;
        esac
        arg_index=$((arg_index+1))
    done
    str+="}"
    echo "$str"
}

# Creates a serialized array of jsons
# Example: serialize_json_array "${arr[@]}"
# Result: [{...}, {...}, ..., {...}]
serialize_json_array() {
    str="["
    arg_index=0
    for var in "$@"; do
        if [ $arg_index -ne 0 ]; then
            str+=", "
        fi
        str+=$var
        arg_index=$((arg_index+1))
    done
    str+="]"

    echo "$str"
}

jsons=()


IFS=$'\n'

getRelativeHistoryFileForShell() {
    # Best effort to map shell to its default history file name
    is_zsh=false
    is_bash=false
    is_fish=false
    is_sh=false
    case "$1" in
        */zsh)
            relativeHistoryFileLocation=".zsh_history"
            is_zsh=true
            return 0
            ;;
        */bash)
            relativeHistoryFileLocation=".bash_history"
            is_bash=true
            return 0
            ;;
        */fish)
            relativeHistoryFileLocation=".local/share/fish/fish_history"
            is_fish=true
            return 0
            ;;
        */sh | */ksh)
            relativeHistoryFileLocation=".sh_history"
            is_sh=true
            return 0
            ;;
    esac
    return 1
}

output_file_path="${resultOutputDir}/${resultFileName}"

parseFish() {
: '
Fish shell history file format:
- cmd: echo "my name is David"
  when: 1643122627
- cmd: ls ../
  when: 1643122649
  paths:
    - ../
- cmd: ls -la ../
  when: 1643122653
  paths:
    - ../
- cmd: history
  when: 1643122691
'
    input_file="$1"
    username="$2"
    # Process the input file and convert it to CSV
    while read -r line; do
        if [[ "$line" =~ "when: " ]]; then
            # Extract timestamp
            timestamp=$(echo "$line" | cut -d ' ' -f 2)
        elif [[ "$line" =~ "cmd: " ]]; then
            # Extract command
            command="${line##*- cmd: }"
            if [ "$destinationCloud" = true ]; then
                echo "$timestamp,$username,$command" >> "$output_file_path"
            fi
            if [ "$destinationDataset" = true ]; then
                previousIFS=$IFS
                IFS=''
                jsons+=($(create_json_from_args "username" "timestamp" "command"))
                IFS=$previousIFS
            fi

            # Reset timestamp and command
            timestamp=""
            command=""
        fi
    done < "$input_file"
    while IFS=';' read -r line; do
        # Check if the line starts with a colon (new command)
        if [[ $line == :* ]]; then
            # If there was a previous command, add it to the output
            if [ -n "$timestamp" ] && [ -n "$command" ]; then
                # Remove leading whitespace and the initial "0;" if present
                command=$(echo "$command" | sed -E 's/^[[:space:]]+//;s/^0;//')
                if [ "$destinationCloud" = true ]; then
                    echo "$timestamp,$username,$command" >> "$output_file_path"
                fi
                if [ "$destinationDataset" = true ]; then
                previousIFS=$IFS
                IFS=''
                jsons+=($(create_json_from_args "username" "timestamp" "command"))
                IFS=$previousIFS
                fi
            fi
            # Extract the timestamp and reset the command
            timestamp=$(echo "$line" | cut -d ':' -f 2)
            command=$(echo "$line" | cut -d ':' -f 3-)
        else
            # Line continues the current command, append it
            command+=";$line"
        fi

    done < "$input_file"

    # Add the last command (if any) to the output
    if [ -n "$timestamp" ] && [ -n "$command" ]; then
        # Remove leading whitespace and the initial "0;" if present
        command=$(echo "$command" | sed -E 's/^[[:space:]]+//;s/^0;//')
        if [ "$destinationCloud" = true ]; then
            echo "$timestamp,$username,$command" >> "$output_file_path"
        fi
        if [ "$destinationDataset" = true ]; then
            previousIFS=$IFS
            IFS=''
            jsons+=($(create_json_from_args "username" "timestamp" "command"))
            IFS=$previousIFS
        fi
    fi
}

parseZSH() {
: '
    : 1662105543:0;bash ./multi-operations-script-bash.sh $(base64 <<< "--verbose")
    : 1662105543:0;bash ./multi-operations-script-bash.sh $(base64 <<< "--verbose --delete")
    : 1662105543:0;bash -c "echo 1"
    : 1662105543:0;bash -c "echo $@"
'
    input_file=$1
    username=$2
    # Process the input file and convert it to CSV or jsons
    while IFS=';' read -r line; do
        # Check if the line starts with a colon (new command)
        if [[ $line == :* ]]; then
            # If there was a previous command, add it to the output
            if [ -n "$timestamp" ] && [ -n "$command" ]; then
                # Remove leading whitespace and the initial "0;" if present
                command=$(echo "$command" | sed -E 's/^[[:space:]]+//;s/^0;//')
                echo "$timestamp,$username,$command" >> "$output_file_path"
                if [ "$destinationCloud" = true ]; then
                    echo "$timestamp,$username,$command" >> "$output_file_path"
                fi
                if [ "$destinationDataset" = true ]; then
                    previousIFS=$IFS
                    IFS=''
                    jsons+=($(create_json_from_args "username" "timestamp" "command"))
                    IFS=$previousIFS
                fi
            fi
            # Extract the timestamp and reset the command
            timestamp=$(echo "$line" | cut -d ':' -f 2)
            command=$(echo "$line" | cut -d ':' -f 3-)
        else
            # Line continues the current command, append it
            command+=";$line"
        fi
    done < "$input_file"

    # Add the last command (if any) to the output
    if [ -n "$timestamp" ] && [ -n "$command" ]; then
        # Remove leading whitespace and the initial "0;" if present
        command=$(echo "$command" | sed -E 's/^[[:space:]]+//;s/^0;//')
        if [ "$destinationCloud" = true ]; then
            echo "$timestamp,$username,$command" >> "$output_file_path"
        fi
        if [ "$destinationDataset" = true ]; then
            previousIFS=$IFS
            IFS=''
            jsons+=($(create_json_from_args "username" "timestamp" "command"))
            IFS=$previousIFS
        fi
    fi
}

parseBash() {
: '
    ls
    echo $1
    pwd
'
    input_file=$1
    username=$2
    while read -r line; do
        # Remove leading and trailing whitespace
        command=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

        # Skip empty lines
        if [ -n "$command" ]; then
            if [ "$destinationCloud" = true ]; then
                echo "$timestamp,$username,$command" >> "$output_file_path"
            fi
            if [ "$destinationDataset" = true ]; then
                # Omitting timestamp since it is not needed to the json format.
                # In bash the timestamp will be empty anyway
                previousIFS=$IFS
                IFS=''
                jsons+=($(create_json_from_args "username" "command"))
                IFS=$previousIFS
            fi
        fi
    done < "$input_file"
}

if [ "$destinationCloud" = true ]; then
    # Add a header to the output CSV
    echo "Timestamp,Username,Command" > "$output_file_path"
fi

if [ "$os" = "mac" ]; then
    for userName in `dscl . list /Users`
        do
            # Some users (f.e root) can have "/var/root /private/var/root" as an entry in NFSHomeDirectory
            # We'd like to split the string by spaces and use the first result.
            IFS=' ' homeDir=($(/usr/bin/dscl . -read "/Users/${userName}" NFSHomeDirectory | /usr/bin/sed 's/NFSHomeDirectory: //'))
            if [ ! -d "${homeDir[0]}" ]; then
                echo "Failed to get home directory for user: ${userName}"
                continue
            fi

            userShell=$(/usr/bin/dscl . -read "/Users/${userName}" UserShell | /usr/bin/sed 's/UserShell: //')
            if [ ! -f "$userShell" ]; then
                echo "Failed to get usershell of user: ${userName}"
                continue
            fi

            echo "Username: ${userName}; Home dir: ${homeDir[0]}. UserShell: ${userShell}"
            if ! getRelativeHistoryFileForShell "$userShell"; then
                echo "Failed to locate history file ${userShell}. User: ${userName}"
                continue
            fi
            # Concatenating user home directory to relative history file path
            absoluteHistoryFilePath="${homeDir}/${relativeHistoryFileLocation}"
            echo "History file: ${absoluteHistoryFilePath}"
            if [ ! -f "${absoluteHistoryFilePath}" ]; then
                echo "${absoluteHistoryFilePath} does not exist"
                continue
            fi

            # Initialize variables to empty strings each iteration so we won't mix between files
            timestamp=""
            command=""
            if [ "$is_fish" = true ]; then
                parseFish "${absoluteHistoryFilePath}" "${userName}"
            elif [ "$is_zsh" = true ]; then
                parseZSH "${absoluteHistoryFilePath}" "${userName}"
            else
                parseBash "${absoluteHistoryFilePath}" "${userName}"
            fi
    done
fi

if [ "$os" = "linux" ]; then
    userHome=$(grep "/bash" /etc/passwd | cut -d ":" -f6 )
    for i in ${userHome}; do
        absoluteHistoryFilePath="${i}/.bash_history"
        if [ -f "$absoluteHistoryFilePath" ]; then
            userName=$(grep "/bash" /etc/passwd | grep "${i}:" | cut -d ":" -f1 )
            # Initialize variables to empty strings each iteration so we won't mix between files
            parseBash "${absoluteHistoryFilePath}" "${userName}"
        fi
    done
fi


if [ -z "$S1_OUTPUT_DESTINATION" ] || [ "$destinationDataset" = true ]; then
    echo $(serialize_json_array "${jsons[@]}") > "$datasetFilePath"
fi

if [ -d "$tempDir" ]; then
    rm -rf "$tempDir"
fi


echo "Done!"
exit 0