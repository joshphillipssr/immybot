#!/bin/bash

checkIfRoot() {
    if ! [ $(id -u) = 0 ]; then
        echo "You must be running this script as root"
        echo "Exiting..."
        exit 126;
    fi
}

detectOS(){
    case $(echo $(uname -s) | tr '[:upper:]' '[:lower:]') in
        darwin*)  os="mac";;
        linux*)   os="linux" ;;
        bsd*)     os="bsd" ;;
        *)        os="unknown" ;;
    esac
}

setResultOutputDir() {
    resultOutputDir="/opt/sentinelone/rso/"  # Default output directory for Linux
    if [ ! -z "$S1_OUTPUT_DIR_PATH" ]; then
        resultOutputDir="$S1_OUTPUT_DIR_PATH"  # Agent supplied the output directory using an environment variable
        if [ ! "$resultOutputDir" = "*/" ]; then
            resultOutputDir="${resultOutputDir}/"  # Append slash at the end
        fi
    fi

    # Create output dir if not exists
    mkdir -p "${resultOutputDir}"
    echo "Script output directory is: $resultOutputDir"
}

echoerr() {
    printf "%s\n" "$*" >&2;
}

checkIfRoot
detectOS
echo "os=$os"
setResultOutputDir


# Create temporary directory for temporary files generated by the script
tempDir="${resultOutputDir}/script_tmp_dir"
mkdir -p "${tempDir}"

setDataSetFilePath() {
    if [ "$os" = "mac" ]; then
        datasetFilePath="/var/sentinelone/rso/dataset.json"
    else
        datasetFilePath="/opt/sentinelone/rso/dataset.json"
    fi

    if [ ! -z "$S1_XDR_OUTPUT_FILE_PATH" ]; then
        datasetFilePath="$S1_XDR_OUTPUT_FILE_PATH"
    fi

    echo "XDR json output file path: $datasetFilePath"
    # Create dataset.json output dir if not exist
    mkdir -p "$(dirname "$datasetFilePath")"
}

# If S1_OUTPUT_DESTINATION variable contains the output destination, create only the file related to destination.
setAddonParserVariables() {
    destinationCloud=true
    destinationDataset=true
    if [ ! -z "$S1_OUTPUT_DESTINATION" ]; then
        if [ "$S1_OUTPUT_DESTINATION" = "Cloud" ]; then
            destinationDataset=false
        elif [ "$S1_OUTPUT_DESTINATION" = "DataSet" ]; then
            destinationCloud=false
        fi
    fi
}

setDataSetFilePath
setAddonParserVariables
scriptFileName=$(basename "$0")
resultFileName="$scriptFileName-results.csv"
shopt -s extglob

# Gets variables by name and creates a json
# where the variable name is the key and its value is the correspondent value
# Example: create_json_from_args "pid" "user"
# Result: {'pid': '{pid variable value}', 'user': '{user variable value}' }
create_json_from_args() {
    str="{"
    arg_index=0
    for key in "$@"; do
        if [ $arg_index -ne 0 ]
        then
            str+=", "
        fi
        value=$(eval "echo \$$key")
        case value in
                ?(+|-)+([0-9])?(\.+([0-9])))  str+="\"$key\":$value"      ;;
            *)                                escapedValue="${value//\\/#}"
                                              escapedValue="${escapedValue//\"/ \\\"}"
                                              str+="\"$key\":\"$escapedValue\"";;
        esac
        arg_index=$((arg_index+1))
    done
    str+="}"
    echo "$str"
}

# Creates a serialized array of jsons
# Example: serialize_json_array "${arr[@]}"
# Result: [{...}, {...}, ..., {...}]
serialize_json_array() {
    str="["
    arg_index=0
    for var in "$@"; do
        if [ $arg_index -ne 0 ]; then
            str+=", "
        fi
        str+=$var
        arg_index=$((arg_index+1))
    done
    str+="]"

    echo "$str"
}

jsons=()


netstatTmpFile="$tempDir/netstatTmpFile.tmp"
if [ "$os" = "mac" ]; then
    netstat -naf inet >${netstatTmpFile}
    nLines=$(wc -l ${netstatTmpFile} | awk '{print $1}')
    sed -i -e 1,2d ${netstatTmpFile}
elif [ "$os" = "linux" ]; then
    netstat -a >${netstatTmpFile}
    nLines=$(wc -l ${netstatTmpFile} | awk '{print $1}')
    sed -i -e 1,2d ${netstatTmpFile}
fi

if [ "$destinationCloud" = true ]; then
    # Print csv header
    echo "Protocol,Recv_q,Send_q,SourceIP,SourcePort,DestinationIP,DestinationPort,State">>${resultOutputDir}${resultFileName}
fi

while IFS=$'\n' read -r line
    do
        protocol=$(echo "$line" | awk '{print $1}')
        recv_q=$(echo "$line" | awk '{print $2}')
        send_q=$(echo "$line" | awk '{print $3}')
        src_ip=$(echo "$line" | awk '{print $4}')
        dst_ip=$(echo "$line" | awk '{print $5}')
        if [ "$os" = "mac" ]; then
            src_port=${src_ip##*.}
            src_ip=${src_ip%.*}
            dst_port=${dst_ip##*:}
            dst_ip=${dst_ip%:*}
        else
            src_port=${src_ip##*:}
            src_ip=${src_ip%:*}
            dst_port=${dst_ip##*:}
            dst_ip=${dst_ip%:*}
        fi

        state=$(echo "$line" | awk '{print $6}')
        if [ ! -z "$protocol" ]
            then
                case $protocol in

                    tcp*|udp*|icmp*|sctp*|ip)
                        diskUsageData=$(du -ah)
                        if [ "$destinationCloud" = true ]; then
                            echo "${protocol},${recv_q},${send_q},${src_ip},${src_port},${dst_ip},${dst_port},${state}">>${resultOutputDir}${resultFileName}
                        fi
                        if [ "$destinationDataset" = true ]; then
                            previousIFS=$IFS
                            IFS=''
                            jsons+=($(create_json_from_args "protocol" "recv_q" "send_q" "src_ip" "src_port" "dst_ip" "dst_port" "state"))
                            IFS=$previousIFS
                        fi
                        ;;

                esac

        fi
done <${netstatTmpFile}



if [ -z "$S1_OUTPUT_DESTINATION" ] || [ "$destinationDataset" = true ]; then
    echo $(serialize_json_array "${jsons[@]}") > "$datasetFilePath"
fi

if [ -d "$tempDir" ]; then
    rm -rf "$tempDir"
fi


echo "Done!"
exit 0