# =================================================================================
# Name:     C9DI-SentinelOne Dynamic Integration Script
# Author:   Josh Phillips
# Contact:  josh@c9cg.com
# Docs:     https://immydocs.c9cg.com
# =================================================================================

$Integration = New-DynamicIntegration -Init {
    param(
        [Parameter(Mandatory)]
        [Uri]$S1Uri,
        [Parameter(Mandatory)]
        [Password(StripValue = $true)]
        $S1ApiKey
    )
    Write-Host "[Init] Init from C9DI-SentinelOne Script Initializing at (UTC): $(Get-Date)"
    Write-Host "[Init] Before we start, let's make sure we have a URI and ApiKey..."
    Write-Host "[Init] This is our `$S1Uri: $S1Uri"
    Write-Host "[Init] For security reasons let's just confirm our `$S1ApiKey exists..."
    Write-Host "[Init] Is `$S1ApiKey not `$null?: $($null -ne $S1ApiKey)"
    Write-Host "[Init] Let's now get started by importing the C9SentinelOneCloud module..."
    Import-Module C9SentinelOneCloud
    Write-Host "[Init] Let's authenticate and define a `$S1AuthHeader object using the Connect-C9S1API function..."
    $S1AuthHeader = Connect-C9S1API -S1Uri $S1Uri -S1APIToken $S1ApiKey
    Write-Host "[Init] Now let's populate the `$IntegrationContext object's custom variables..."
    $IntegrationContext.S1Uri = $S1Uri
    Write-Host "[Init] `$IntegrationContext.S1Uri: $IntegrationContext.S1Uri"
    $IntegrationContext.AuthHeader = $S1AuthHeader
    Write-Host "[Init] `IntegrationContext.AuthHeader: $IntegrationContext.AuthHeader"
    Write-Host "[Init] We're all done. Let's finish by printing the result..."
    [OpResult]::Ok()
    
} -HealthCheck { #Runs every minute
    [CmdletBinding()]
    [OutputType([HealthCheckResult])]
    param()
    Write-Host "[HealthCheck] HealthCheck C9DI-SentinelOne starting at (UTC): $(Get-Date) ---"
    Write-Host "[HealthCheck] Before we start, let's see what custom properties we have in the `$IntegrationContext object..."
    $IntegrationContext | Format-List *

    try {
        Write-Host "[HealthCheck] Now let's import our C9SentinelOneCloud module..."
        Import-Module C9SentinelOneCloud
        Write-Host "[HealthCheck] We're ready to perform the HealthCheck with Invoke-C9S1RestMethod..."
        Write-Host "[HealthCheck] Let's run our test against the 'system/info API endpoint..."
        Invoke-C9S1RestMethod -Endpoint 'system/info' -Verbose -ErrorAction Stop | Out-Null
        Write-Host "[HealthCheck] We're done with the HealthCheck. Here is the result..."
        return New-HealthyResult
    }
    catch {
        $errorMessage = "[HealthCheck] Health check FAILED. Error: $($_.Exception.Message)"
        Write-Error $errorMessage
        return New-UnhealthyResult -Message $errorMessage
    }
}

# --- AUTHENTICATED DOWNLOAD CAPABILITY (Corrected Signature) ---
# This capability allows the native ImmyBot downloader to request the necessary
# authentication headers for a specific URL before it attempts the download.
$Integration | Add-DynamicIntegrationCapability -Interface ISupportsAuthenticatedDownload -GetAuthHeader {
    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param()

    # This capability's only job is to return the pre-existing authentication header
    # that was created and stored in the -Init block.
    Write-Host "[GetAuthHeader] Capability Invoked."
    Write-Host "[GetAuthHeader] Before we start, let's see what custom properties we have in the `$IntegrationContext object..."
    $IntegrationContext | Format-List *
    
    Write-Host "[GetAuthHeader] Verifying the presence of the implicit `$Url variable..."
    if (-not $Url) {
        throw "[GetAuthHeader] CRITICAL: The platform did not provide the implicit `$Url variable to this context."
    }
    Write-Host "[GetAuthHeader] The URL provided by the platform is: $($Url)"
    
    # We only provide the header for our S1 API. For any other URL, we'd return $null.
    if ($Url.Host -like "*.sentinelone.net") {
        return $IntegrationContext.AuthHeader
    } else {
        # For other URLs, no auth is needed.
        return $null
    }
}

# Gets list of all tenants from S1 API
$Integration | Add-DynamicIntegrationCapability -Interface ISupportsListingClients -GetClients {
    [CmdletBinding()]
    [OutputType([Immybot.Backend.Domain.Providers.IProviderClientDetails[]])]
    param()
    Write-Host "--- [GET-CLIENTS] Running: $(Get-Date) ---"
    Import-Module C9SentinelOneCloud
    Get-C9S1Site -Verbose | ForEach-Object {
        if ($_.state -eq "active") {
            New-IntegrationClient -ClientId $_.Id -ClientName $_.Name
        }
    }
}

# Gets list of Agents from S1 API every 30 minutes
$Integration | Add-DynamicIntegrationCapability -Interface ISupportsListingAgents -GetAgents {
    [CmdletBinding()]
    [OutputType([Immybot.Backend.Domain.Providers.IProviderAgentDetails[]])]
    param(
        [Parameter()]
        [string[]]$clientIds = $null
    )
    Write-Host "--- [GET-AGENTS] Running: $(Get-Date) ---"
    Import-Module C9SentinelOneCloud
    Get-C9S1Agent -Verbose -SiteID $clientIds | ForEach-Object {
        New-IntegrationAgent -Name $_.computerName `
            -SerialNumber $_.serialNumber `
            -OSName $_.osName `
            -Manufacturer $_.modelName `
            -ClientId $_.siteId `
            -AgentId $_.uuid `
            -IsOnline $true `
            -AgentVersion $_.agentVersion `
            -SupportsRunningScripts $false `
            -SupportsOnlineStatus $false
    }
}

# This capability allows the integration to provide the site-specific installation token.
$Integration |  Add-DynamicIntegrationCapability -Interface ISupportsTenantInstallToken -GetTenantInstallToken {
    [CmdletBinding()]
    [OutputType([System.String])]
    param(
        [Parameter(Mandatory=$true)]
        [string]$clientId
    )
    # Write-Host "[GetTenantInstallToken] Capability Invoked."
    # Write-Host "[GetTenantInstallToken] Before we start, let's see what custom properties we have in the `$IntegrationContext object..."
    # $IntegrationContext | Format-List *
    Import-Module C9SentinelOneCloud
    Get-C9S1Site -Id $clientId | ForEach-Object{ $_.registrationToken}
}

# Deletes an offline agent from S1 API
 $Integration | Add-DynamicIntegrationCapability -Interface ISupportsDeletingOfflineAgent -DeleteAgent {
    [CmdletBinding()]
    [OutputType([System.Void])]
    param(
        [Parameter(Mandatory=$true)]
            [Immybot.Backend.Domain.Providers.IProviderAgentDetails]$agent
    )
    Write-Host "--- [DELETE-AGENT] Running: $(Get-Date) ---"
    # return "implement me" # Commenting out placeholder to ensure script validity
}

$Integration | Add-DynamicIntegrationCapability -Interface ISupportsDynamicVersions -GetDynamicVersions {
    [CmdletBinding()]
    [OutputType([Immybot.Backend.Domain.Models.DynamicVersion[]])]
    param(
        [Parameter(Mandatory = $True)]
        [System.String]$ExternalClientId
    )
    Write-Host "[GetDynamicVersions] Before we start, let's see what custom properties we have in the `$IntegrationContext object..."
    $IntegrationContext | Format-List *
    Import-Module C9SentinelOneCloud
    
    $authHeader = $IntegrationContext.AuthHeader
    if (-not $authHeader) {
        throw "AuthHeader not found in IntegrationContext. The -Init block may have failed."
    }

    Write-Host "[GetDynamicVersions] GetDynamicVersions invoked. AuthHeader is present. Processing packages..."

    $GroupedPackages = Get-C9S1AvailablePackages
    foreach ($group in $GroupedPackages.GetEnumerator()) {
        
        try {
            # --- START DIAGNOSTIC HARNESS ---
            # First, we log the object we are about to process so we can see its structure.
            $versionDataJson = $group.Value | ConvertTo-Json -Depth 5
            Write-Host "[GetDynamicVersions] Processing package object: $versionDataJson"
            # --- END DIAGNOSTIC HARNESS ---

            $versionData = $group.Value

            # This is the logic block we need to test
            if ($versionData.EXE) {
                $package = $versionData.EXE
                $packageType = 'Executable'
            }
            elseif ($versionData.MSI) {
                # Based on the error, "MSI" is not a valid PackageType.
                # We will skip MSI packages for now to see if this resolves the error.
                # If we need MSI support, we must find the correct string for the enum.
                Write-Host "[GetDynamicVersions] Skipping MSI package for version $($versionData.Version)."
                continue # Skip to the next item in the loop
            }
            else {
                # This handles the case where the object has neither EXE nor MSI.
                throw "[GetDynamicVersions] Package object for version $($versionData.Version) is malformed and contains no installer."
            }
            
            # Create the standard DynamicVersion object
            $versionObject = New-DynamicVersion -Url $package.link -Version $versionData.Version -FileName $package.fileName -Architecture $versionData.Architecture -PackageType $packageType
            
            # Attach the auth header directly to the object.
            $versionObject | Add-Member -MemberType NoteProperty -Name 'AuthHeader' -Value $authHeader
            
            Write-Host "[GetDynamicVersions] Created DynamicVersion for $($versionData.Version) and attached AuthHeader."
            
            # Return the modified object to the platform
            $versionObject
        }
        catch {
            # --- CATCH BLOCK FOR DIAGNOSTICS ---
            # If any part of the 'try' block fails, we land here.
            # Instead of crashing, we log the error and the data that caused it.
            $errorMessage = $_.Exception.Message
            $badObjectJson = $group.Value | ConvertTo-Json -Depth 5
            Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            Write-Warning "!!! [GetDynamicVersions] Failed to process a package object."
            Write-Warning "!!! [GetDynamicVersions] Error: $errorMessage"
            Write-Warning "!!! [GetDynamicVersions] The object that caused the failure was: $badObjectJson"
            Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            # We continue to the next loop iteration instead of stopping the whole script.
        }
    }
}

$Integration | Add-DynamicIntegrationCapability -Interface ISupportsTenantUninstallToken -GetTenantUninstallToken {
    [CmdletBinding()]
    [OutputType([System.String])]
    param(
        [Parameter(Mandatory=$true)]
        [string]$clientId
    )
    Import-Module C9SentinelOneCloud
    $siteObject = Get-C9S1Site -Id $clientId
    return $siteObject.passphrase
}

# Capability to provide the uninstall token (passphrase) for a specific AGENT.
$Integration | Add-DynamicIntegrationCapability -Interface ISupportsAgentUninstallToken -GetAgentUninstallToken {
    [CmdletBinding()]
    [OutputType([System.String])]
    param(
        [Parameter(Mandatory=$true)]
        [string]$agentId
    )
    Write-Verbose "GetAgentUninstallToken capability received agentId: $agentId"
    Import-Module C9SentinelOne
    $passphrase = Get-C9S1AgentPassphrase -AgentId $agentId
    return $passphrase
}

$Integration | Add-DynamicIntegrationCapability -Interface ISupportsInventoryIdentification -GetInventoryScript {
    [CmdletBinding()]
    param()

Invoke-ImmyCommand {
        try {
            $path = Resolve-Path "C:\Program Files\SentinelOne\Sentinel Agent*\SentinelCtl.exe" -ErrorAction Stop
        } catch {
            Write-Warning "Path not found: $_"
            return
        }
        if (!$path) { return }
        . $path.Path agent_id
    }
}

return $Integration
