param(
    [Parameter(
        Position=0, 
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true)
    ]
    $Computer,
    [switch]$Passthru
)
if(!$Computer)
{
    $Computer = Get-ImmyComputer
}
$Computer | Invoke-ImmyCommand {
    Function IsGuid {
    param([string]$PossibleGuid)
    try {
        $Guid = New-Object "Guid" -ArgumentList $PossibleGuid
        return $true;
    }
    catch {
        return $false
    }
    }

    Function Is-Sandbox {
    $CS = gwmi Win32_ComputerSystem
    return ( (IsGuid $CS.DNSHostName) -and $CS.DNSHostName.Substring(0, 15) -like $CS.Name -and $CS.Manufacturer -eq "Microsoft Corporation" -and $CS.Model -eq "Virtual Machine")
    }

    function Test-PendingReboot {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [Alias("CN", "Computer")]
        [String[]]
        $ComputerName = $env:COMPUTERNAME,
        [Parameter()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.CredentialAttribute()]
        $Credential,
        [Parameter()]
        [Switch]
        $Detailed,
        [Parameter()]
        [Switch]
        $SkipConfigurationManagerClientCheck,
        [Parameter()]
        [Switch]
        $SkipPendingFileRenameOperationsCheck
    )
    process {
        foreach ($computer in $ComputerName) {
        if (Is-SandBox -eq $true) {
            [PSCustomObject]@{
            ComputerName    = $computer
            IsRebootPending = $false
            }
            return
        }
        try {
            $invokeWmiMethodParameters = @{
            Namespace    = 'root/default'
            Class        = 'StdRegProv'
            Name         = 'EnumKey'
            ComputerName = $computer
            ErrorAction  = 'Stop'
            }
            $hklm = [UInt32] "0x80000002"
            if ($PSBoundParameters.ContainsKey('Credential')) {
            $invokeWmiMethodParameters.Credential = $Credential
            }
            ## Query the Component Based Servicing Reg Key
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\')
            $registryComponentBasedServicing = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames -contains 'RebootPending'
            ## Query WUAU from the registry
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\')
            $registryWindowsUpdateAutoUpdate = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames -contains 'RebootRequired'
            ## Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Services\\Netlogon')
            $registryNetlogon = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames
            $pendingDomainJoin = ($registryNetlogon -contains 'JoinDomain') -or ($registryNetlogon -contains 'AvoidSpnSet')
            ## Query ComputerName and ActiveComputerName from the registry and setting the MethodName to GetMultiStringValue
            $invokeWmiMethodParameters.Name = 'GetMultiStringValue'
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName\\', 'ComputerName')
            $registryActiveComputerName = Invoke-WmiMethod @invokeWmiMethodParameters
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName\\', 'ComputerName')
            $registryComputerName = Invoke-WmiMethod @invokeWmiMethodParameters
            $pendingComputerRename = $registryActiveComputerName -ne $registryComputerName -or $pendingDomainJoin
            ## Query PendingFileRenameOperations from the registry
            if (-not $PSBoundParameters.ContainsKey('SkipPendingFileRenameOperationsCheck')) {
            $registryPendingFileRenameOperations = $(get-itemproperty -path 'HKLM:\system\CurrentControlSet\Control\Session Manager' -name "PendingFileRenameOperations" -ErrorAction SilentlyContinue).PendingFileRenameOperations
            $registryPendingFileRenameOperationsBool = [bool]$registryPendingFileRenameOperations
            }
            ## Query ClientSDK for pending reboot status, unless SkipConfigurationManagerClientCheck is present
            if (-not $PSBoundParameters.ContainsKey('SkipConfigurationManagerClientCheck')) {
            $invokeWmiMethodParameters.NameSpace = 'ROOT\\ccm\\ClientSDK'
            $invokeWmiMethodParameters.Class = 'CCM_ClientUtilities'
            $invokeWmiMethodParameters.Name = 'DetermineifRebootPending'
            $invokeWmiMethodParameters.Remove('ArgumentList')
            try {
                $sccmClientSDK = Invoke-WmiMethod @invokeWmiMethodParameters
                $systemCenterConfigManager = $sccmClientSDK.ReturnValue -eq 0 -and ($sccmClientSDK.IsHardRebootPending -or $sccmClientSDK.RebootPending)
            }
            catch {
                $systemCenterConfigManager = $null
                Write-Verbose -Message ($script:localizedData.invokeWmiClientSDKError -f $computer)
            }
            }
            # This is a DateTime value left behind by Windows Update Orchestrator when the computer needs to reboot because of an update
            # It is typically not present, but if it is in the future, the computer is pending a reboot
            $pendingRebootStartTime = Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings' -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'PendingRebootStartTime' -ErrorAction SilentlyContinue

            $isRebootPending = $registryComponentBasedServicing -or `
            $pendingComputerRename -or `
            $pendingDomainJoin -or `
            $registryPendingFileRenameOperationsBool -or `
            $systemCenterConfigManager -or `
            $registryWindowsUpdateAutoUpdate -or `
            ([DateTime]$pendingRebootStartTime -gt (Get-Date).ToUniversalTime())
            if ($PSBoundParameters.ContainsKey('Detailed')) {
            [PSCustomObject]@{
                ComputerName                     = $computer
                ComponentBasedServicing          = $registryComponentBasedServicing
                PendingComputerRenameDomainJoin  = $pendingComputerRename
                PendingFileRenameOperations      = $registryPendingFileRenameOperationsBool
                PendingFileRenameOperationsValue = $registryPendingFileRenameOperations
                SystemCenterConfigManager        = $systemCenterConfigManager
                WindowsUpdateAutoUpdate          = $registryWindowsUpdateAutoUpdate
                PendingRebootStartTime           = $pendingRebootStartTime
                IsRebootPending                  = $isRebootPending
            }
            }
            else {
            [PSCustomObject]@{
                ComputerName    = $computer
                IsRebootPending = $isRebootPending
            }
            }
        }
        catch {
            Write-Verbose "$Computer`: $_"
        }
        }
    }
    }

    $result = Test-PendingReboot -Detailed
    if($Using:Passthru) {
        return $result
    }
    Write-Host ($result | Format-List | Out-String)
    return $result.IsRebootPending
}

<#
$result = Invoke-ImmyCommand {
    function Test-PendingReboot
    {
    [CmdletBinding()]
    param(
        [Parameter()]
        [Switch]
        $Detailed,
        [Parameter()]
        [Switch]
        $SkipConfigurationManagerClientCheck,
        [Parameter()]
        [Switch]
        $SkipPendingFileRenameOperationsCheck
    )
    process
    {
        foreach ($computer in $ComputerName)
        {
        try
        {
            $invokeWmiMethodParameters = @{
            Namespace    = 'root/default'
            Class        = 'StdRegProv'
            Name         = 'EnumKey'
            ComputerName = $computer
            ErrorAction  = 'Stop'
            }
            $hklm = [UInt32] "0x80000002"
            if ($PSBoundParameters.ContainsKey('Credential'))
            {
            $invokeWmiMethodParameters.Credential = $Credential
            }
            ## Query the Component Based Servicing Reg Key
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\')
            $registryComponentBasedServicing = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames -contains 'RebootPending'
            ## Query WUAU from the registry
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\')
            $registryWindowsUpdateAutoUpdate = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames -contains 'RebootRequired'
            $microsoftUpdateSystemInfoRebootFlag = Invoke-ImmyCommand { #Should be replaced with a function script so that this can be used in Windows Updates script as well.
                $SystemInfo = New-Object -ComObject Microsoft.Update.SystemInfo
                return [bool]$SystemInfo.RebootRequired
            }
            ## Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Services\\Netlogon')
            $registryNetlogon = (Invoke-WmiMethod @invokeWmiMethodParameters).sNames
            $pendingDomainJoin = ($registryNetlogon -contains 'JoinDomain') -or ($registryNetlogon -contains 'AvoidSpnSet')
            ## Query ComputerName and ActiveComputerName from the registry and setting the MethodName to GetMultiStringValue
            $invokeWmiMethodParameters.Name = 'GetMultiStringValue'
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName\\', 'ComputerName')
            $registryActiveComputerName = Invoke-WmiMethod @invokeWmiMethodParameters
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName\\', 'ComputerName')
            $registryComputerName = Invoke-WmiMethod @invokeWmiMethodParameters
            $pendingComputerRename = $registryActiveComputerName -ne $registryComputerName -or $pendingDomainJoin
            ## Query PendingFileRenameOperations from the registry
            if (-not $PSBoundParameters.ContainsKey('SkipPendingFileRenameOperationsCheck'))
            {
            $invokeWmiMethodParameters.ArgumentList = @($hklm, 'SYSTEM\\CurrentControlSet\\Control\\Session Manager\\', 'PendingFileRenameOperations')
            $registryPendingFileRenameOperations = (Invoke-WmiMethod @invokeWmiMethodParameters).sValue
            $registryPendingFileRenameOperationsBool = [bool]$registryPendingFileRenameOperations
            }
            ## Query ClientSDK for pending reboot status, unless SkipConfigurationManagerClientCheck is present
            if (-not $PSBoundParameters.ContainsKey('SkipConfigurationManagerClientCheck'))
            {
            $invokeWmiMethodParameters.NameSpace = 'ROOT\\ccm\\ClientSDK'
            $invokeWmiMethodParameters.Class = 'CCM_ClientUtilities'
            $invokeWmiMethodParameters.Name = 'DetermineifRebootPending'
            $invokeWmiMethodParameters.Remove('ArgumentList')
            try
            {
                $sccmClientSDK = Invoke-WmiMethod @invokeWmiMethodParameters
                $systemCenterConfigManager = $sccmClientSDK.ReturnValue -eq 0 -and ($sccmClientSDK.IsHardRebootPending -or $sccmClientSDK.RebootPending)
            }
            catch
            {
                $systemCenterConfigManager = $null
                Write-Verbose -Message ($script:localizedData.invokeWmiClientSDKError -f $computer)
            }
            }
            $pendingRebootStartTime = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings' -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'PendingRebootStartTime' -ErrorAction SilentlyContinue) -ne $null

            $isRebootPending = $registryComponentBasedServicing -or `
            $pendingComputerRename -or `
            $pendingDomainJoin -or `
            $registryPendingFileRenameOperationsBool -or `
            $systemCenterConfigManager -or `
            $registryWindowsUpdateAutoUpdate -or `
            $microsoftUpdateSystemInfoRebootFlag -or `
            $pendingRebootStartTime
            if ($PSBoundParameters.ContainsKey('Detailed'))
            {
            [PSCustomObject]@{
                ComputerName                     = $computer
                ComponentBasedServicing          = $registryComponentBasedServicing
                PendingComputerRenameDomainJoin  = $pendingComputerRename
                PendingFileRenameOperations      = $registryPendingFileRenameOperationsBool
                PendingFileRenameOperationsValue = $registryPendingFileRenameOperations
                SystemCenterConfigManager        = $systemCenterConfigManager
                WindowsUpdateAutoUpdate          = $registryWindowsUpdateAutoUpdate
                WindowsUpdatesPendingReboot      = $microsoftUpdateSystemInfoRebootFlag
                IsRebootPending                  = $isRebootPending
            }
            }
            else
            {
            [PSCustomObject]@{
                ComputerName    = $computer
                IsRebootPending = $isRebootPending
            }
            }
        }
        catch
        {
            Write-Verbose "$Computer`: $_"
        }
        }
    }
    }
    Test-PendingReboot | select -ExpandProperty IsRebootPending
}
Write-Host $result
if(!$result)
{
    return $false    
}
else
{
    return $result
}
#>